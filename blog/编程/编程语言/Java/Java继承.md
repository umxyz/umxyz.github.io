# Java继承

## 1. 问题：

### 1、比如两个类父类：

`Person` 子类 `Student extends Person`在使用时候，这样写：

`Person person=null; //声明对象person=new Student(); //创建对象`这样看来 声明的时候，是父类，而在产生对象的时候，实际的对象是子类。怎么理解？？？

## 2. 知识点：

### Java的多态性

>    面向对象编程有三个特征，即封装、继承和多态。封装隐藏了类的内部实现机制，从而可以在不影响使用者的前提下改变类的内部结构，同时保护了数据。继承是为了重用父类代码，同时为实现多态性作准备。那么什么是多态呢？方法的重写、重载与动态连接构成多态性。Java之所以引入多态的概念，原因之一是它在类的继承问题上和C++不同，后者允许多继承，这确实给其带来的非常强大的功能，但是复杂的继承关系也给C++开发者带来了更大的麻烦，为了规避风险，Java只允许单继承，派生类与基类间有IS-A的关系（即“猫”is a “动物”）。这样做虽然保证了继承关系的简单明了，但是势必在功能上有很大的限制，所以，Java引入了多态性的概念以弥补这点的不足，此外，抽象类和接口也是解决单继承规定限制的重要手段。同时，多态也是面向对象编程的精髓所在。
>

## 3. 解释：

要理解多态性，首先要知道什么是“向上转型”。
我定义了一个子类Cat，它继承了Animal类，那么后者就是前者是父类。我可以通过
`Cat c = new Cat();`
实例化一个Cat的对象，这个不难理解。但当我这样定义时：
`Animal a = new Cat();`
这代表什么意思呢？
很简单，它表示我定义了一个Animal类型的引用，指向新建的Cat类型的对象。由于Cat是继承自它的父类Animal，所以Animal类型的引用是可以指向Cat类型的对象的。那么这样做有什么意义呢？因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特，
定义一个父类类型的引用指向一个子类的对象既可以使用子类强大的功能，又可以抽取父类的共性。
所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，它是无可奈何的；
同时，父类中的一个方法只有在在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用；
对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。
看下面这段程序：

```java
class Father{
    public void func1(){
        func2();
    }
    //这是父类中的func2()方法，因为下面的子类中重写了该方法所以在父类类型的引用中调用时，这个方法将不再有效
    //取而代之的是将调用子类中重写的func2()方法
    public void func2(){
        System.out.println("AAA");
    }
}

class Child extends Father{
    //func1(int i)是对func1()方法的一个重载由于在父类中没有定义这个方法，所以它不能被父类类型的引用调用
    //所以在下面的main方法中child.func1(68)是不对的
    public void func1(int i){
        System.out.println("BBB");
    }
    //func2()重写了父类Father中的func2()方法如果父类类型的引用中调用了func2()方法，那么必然是子类中重写的这个方法
    public void func2(){
        System.out.println("CCC");
    }
}

public class PolymorphismTest {
    public static void main(String[] args) {
        Father child = new Child();
        child.func1();//打印结果将会是什么？
    }
}
```

   上面的程序是个很典型的多态的例子。子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。
那么该程序将会打印出什么样的结果呢？很显然，应该是“CCC”。

## 4. 总结：

### 对于多态，可以总结它为：

> 1. 使用父类类型的引用指向子类的对象；
> 2. 该引用只能调用父类中定义的方法和变量；
> 3. 如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）
> 4. 变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。

## 5. 通俗理解

父类类型的引用指向子类的对象。就你这个test3，你记住，它只能调用自己的方法，但是如果自己的方法被子类覆盖了，那么调用的就是子类的。你的gettest3这个方法是子类独有的，所以父类类型的引用test3用不了。 **简单的说，就是自己用自己的，儿子有父亲一样的，就用儿子的。省点钱是点。儿子独有的，父亲不会用，所以不能用 。**